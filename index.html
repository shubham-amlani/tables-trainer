<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tables + Trig Trainer — Enhanced</title>
    <style>
      /* ---------- Vars & Resets ---------- */
      :root {
        --bg: #071428;
        --card: #07101a;
        --muted: #94a3b8;
        --text: #e6eef8;
        --accent: #2563eb;
        --accent-2: #7c3aed;
        --pill-border: rgba(255, 255, 255, 0.06);
        --success: #16a34a;
        --danger: #ef4444;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: linear-gradient(180deg, #071028 0%, #071428 60%);
        -webkit-font-smoothing: antialiased;
        box-sizing: border-box;
        overflow-x: hidden;
      }
      * {
        box-sizing: inherit;
        font-family: Inter, system-ui, "Segoe UI", Roboto, Arial, sans-serif;
      }
      body {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 20px;
        color: var(--text);
      }

      /* ---------- App ---------- */
      .app {
        width: 100%;
        max-width: 1150px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 16px 40px rgba(2, 6, 23, 0.6);
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }
      h1 {
        margin: 0;
        font-size: clamp(18px, 2.6vw, 26px);
        line-height: 1.05;
      }
      .subtitle {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
        text-align: right;
        max-width: 60ch;
      }

      .controls {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .left-controls {
        display: flex;
        flex-direction: column;
        gap: 12px;
        flex: 1 1 680px;
        min-width: 240px;
      }
      .right-controls {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-end;
        min-width: 220px;
      }

      /* mode tabs */
      .mode-tabs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .mode-btn {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.01em;
      }
      .mode-btn.active {
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: #fff;
        box-shadow: 0 10px 26px rgba(37, 99, 235, 0.14);
        border-color: transparent;
      }

      /* trig unit toggle (only visible in trig mode) */
      .trig-unit-toggle {
        display: flex;
        gap: 6px;
        margin-top: 6px;
        flex-wrap: wrap;
      }
      .trig-unit-btn {
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        background: transparent;
        color: var(--muted);
        font-size: 12px;
        cursor: pointer;
      }
      .trig-unit-btn.active {
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: #fff;
        border-color: transparent;
      }

      /* section header row */
      .section-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .section-title {
        font-size: 13px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      /* selectors grid */
      .tables-select {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
        gap: 10px;
      }
      .small-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
        gap: 8px;
      }

      /* capsule design (buttons) */
      .table-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 10px 12px;
        border-radius: 14px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
        border: 1px solid var(--pill-border);
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02),
          0 6px 18px rgba(2, 6, 23, 0.45);
        min-height: 44px;
        transition: transform 0.14s ease, box-shadow 0.14s ease;
      }
      .table-pill:hover {
        transform: translateY(-4px);
        box-shadow: 0 14px 36px rgba(2, 6, 23, 0.55);
      }
      .table-pill.active {
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: #fff;
        border-color: transparent;
        box-shadow: 0 12px 30px rgba(37, 99, 235, 0.16);
      }
      .select-all-btn {
        font-size: 13px;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: var(--text);
        cursor: pointer;
      }

      /* buttons */
      .buttons-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      .btn {
        border: 0;
        border-radius: 999px;
        padding: 10px 14px;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: #fff;
        cursor: pointer;
        min-height: 44px;
        font-weight: 700;
      }
      .btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.04);
        color: var(--text);
      }
      .btn.danger {
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.12);
        color: var(--danger);
      }

      /* question card */
      .question-card {
        padding: 18px;
        border-radius: 14px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          rgba(255, 255, 255, 0.005)
        );
        border: 1px solid rgba(255, 255, 255, 0.02);
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }
      .question {
        font-weight: 900;
        font-size: clamp(26px, 7vw, 56px);
        margin: 0;
        letter-spacing: 0.01em;
      }

      .input-row {
        width: 100%;
        display: flex;
        justify-content: center;
      }
      input[type="text"] {
        font-size: 20px;
        padding: 12px 14px;
        width: 220px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        text-align: center;
        outline: none;
      }
      input::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }
      input:focus {
        box-shadow: 0 8px 24px rgba(37, 99, 235, 0.12);
        border-color: rgba(37, 99, 235, 0.22);
      }

      .feedback {
        min-height: 22px;
        font-weight: 700;
        text-align: center;
      }
      .feedback.correct {
        color: var(--success);
      }
      .feedback.wrong {
        color: var(--danger);
      }

      .timing {
        font-size: 13px;
        color: var(--muted);
        text-align: center;
      }

      .stats {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .stat-chip {
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.02);
        color: var(--muted);
        font-size: 13px;
      }

      .section {
        margin-top: 8px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.02);
      }
      .note {
        font-size: 12px;
        color: var(--muted);
      }

      .flash-correct {
        animation: flashCorrect 0.7s;
      }
      .flash-wrong {
        animation: flashWrong 0.7s;
      }
      @keyframes flashCorrect {
        0% {
          box-shadow: 0 0 0 rgba(16, 185, 129, 0);
        }
        20% {
          box-shadow: 0 12px 40px rgba(16, 185, 129, 0.12);
        }
        100% {
          box-shadow: 0 0 0 rgba(16, 185, 129, 0);
        }
      }
      @keyframes flashWrong {
        0% {
          box-shadow: 0 0 0 rgba(239, 68, 68, 0);
        }
        20% {
          box-shadow: 0 12px 40px rgba(239, 68, 68, 0.12);
        }
        100% {
          box-shadow: 0 0 0 rgba(239, 68, 68, 0);
        }
      }

      /* trig input toolbar */
      .trig-toolbar {
        margin-top: 6px;
        display: none;
        gap: 6px;
        justify-content: center;
        flex-wrap: wrap;
      }
      .trig-toolbar-btn {
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        background: rgba(15, 23, 42, 0.8);
        color: #e5edff;
        font-size: 13px;
        padding: 4px 10px;
        cursor: pointer;
      }
      .trig-toolbar-text {
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
        text-align: center;
      }

      @media (max-width: 920px) {
        .tables-select {
          grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
        }
        .small-grid {
          grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
        }
        .left-controls {
          flex-basis: 100%;
        }
        .right-controls {
          width: 100%;
          align-items: stretch;
        }
        .buttons-group {
          justify-content: space-between;
        }
      }
      @media (max-width: 640px) {
        input[type="text"] {
          width: 160px;
        }
        .table-pill {
          padding: 8px 10px;
          min-height: 38px;
          border-radius: 12px;
        }
        .tables-select {
          gap: 6px;
        }
        .small-grid {
          gap: 6px;
        }
      }
      header > * {
        min-width: 0;
      }
    </style>
  </head>

  <body>
    <div class="app" role="main" aria-label="Tables + Trig Trainer">
      <header>
        <h1>Tables + Trig Trainer</h1>
        <p class="subtitle">
          Practice Tables (×1–10), Squares (1–30), Cubes (1–20), Mixed mode and
          Trig ratio table with surds.
        </p>
      </header>

      <div class="controls">
        <div class="left-controls">
          <div class="mode-tabs" role="tablist" aria-label="Practice modes">
            <button
              class="mode-btn active"
              id="modeTablesBtn"
              data-mode="tables"
            >
              Tables
            </button>
            <button class="mode-btn" id="modeSquaresBtn" data-mode="squares">
              Squares
            </button>
            <button class="mode-btn" id="modeCubesBtn" data-mode="cubes">
              Cubes
            </button>
            <button class="mode-btn" id="modeMixedBtn" data-mode="mixed">
              Mixed
            </button>
            <button class="mode-btn" id="modeTrigBtn" data-mode="trig">
              Trig
            </button>
          </div>

          <!-- Trig unit toggle (only in trig mode) -->
          <div
            class="trig-unit-toggle"
            id="trigUnitToggle"
            style="display: none"
          >
            <button
              class="trig-unit-btn active"
              data-unit="deg"
              id="trigDegBtn"
            >
              Degrees
            </button>
            <button class="trig-unit-btn" data-unit="rad" id="trigRadBtn">
              Radians
            </button>
          </div>

          <!-- Tables section -->
          <div class="section" id="tablesSection">
            <div class="section-row">
              <div class="section-title">Select tables (1–20):</div>
              <div>
                <button class="select-all-btn" id="selectAllTablesBtn">
                  Select All
                </button>
              </div>
            </div>
            <div class="tables-select" id="tablesSelect"></div>
          </div>

          <!-- Squares section -->
          <div class="section" id="squaresSection" style="display: none">
            <div class="section-row">
              <div class="section-title">Select squares (1–30):</div>
              <div>
                <button class="select-all-btn" id="selectAllSquaresBtn">
                  Select All
                </button>
              </div>
            </div>
            <div class="small-grid" id="squaresSelect"></div>
          </div>

          <!-- Cubes section -->
          <div class="section" id="cubesSection" style="display: none">
            <div class="section-row">
              <div class="section-title">Select cubes (1–20):</div>
              <div>
                <button class="select-all-btn" id="selectAllCubesBtn">
                  Select All
                </button>
              </div>
            </div>
            <div class="small-grid" id="cubesSelect"></div>
          </div>

          <div class="note">
            Mixed mode will ask questions from all the currently selected items
            (tables + squares + cubes). Trig mode uses standard angles 0°, 30°,
            45°, 60°, 90° with sin/cos/tan/cosec/sec/cot.
          </div>
        </div>

        <div class="right-controls">
          <div class="buttons-group" role="toolbar" aria-label="Actions">
            <button class="btn" id="nextBtn">Start / Next</button>
            <button class="btn secondary" id="pauseBtn" type="button">
              Pause
            </button>
            <button class="btn secondary" id="skipBtn" type="button">
              Skip
            </button>
            <button class="btn secondary" id="downloadBtn" type="button">
              Download log
            </button>
            <button class="btn danger" id="resetBtn" type="button">
              Reset stats
            </button>
          </div>
        </div>
      </div>

      <!-- Main question card -->
      <div class="question-card" id="questionCard" aria-live="polite">
        <div class="question" id="questionDisplay">– × –</div>

        <div class="input-row">
          <input
            type="text"
            id="answerInput"
            placeholder="Type answer & press Enter"
            autocomplete="off"
            inputmode="numeric"
            aria-label="Answer input"
          />
        </div>

        <!-- Trig toolbar: only visible in trig mode -->
        <div class="trig-toolbar" id="trigToolbar">
          <button class="trig-toolbar-btn" data-insert="√">√</button>
          <button class="trig-toolbar-btn" data-insert="root">root</button>
          <button class="trig-toolbar-btn" data-insert="/">/</button>
          <button class="trig-toolbar-btn" data-insert="sqrt()">sqrt()</button>
        </div>
        <div
          class="trig-toolbar-text"
          id="trigToolbarText"
          style="display: none"
        >
          For trig: use forms like <b>√3/2</b>, <b>1/√3</b>, <b>√2/2</b>,
          <b>2/√3</b>, etc. Buttons help you type √ and /.
        </div>

        <div
          class="feedback"
          id="feedback"
          role="status"
          aria-live="polite"
        ></div>
        <div class="timing" id="timingInfo" aria-hidden="true"></div>

        <div class="stats">
          <div class="stat-chip" id="totalStat">Total: 0</div>
          <div class="stat-chip" id="accuracyStat">Accuracy: –</div>
          <div class="stat-chip" id="avgTimeStat">Avg time: –</div>
          <div class="stat-chip" id="focusStat">Focus: slow/wrong ones</div>
        </div>
      </div>
    </div>

    <script>
      /* ===================== Tables/Squares/Cubes/Trig Trainer ===================== */
      const STORAGE_KEY_STATS = "tablesTrainerStatsV4";
      const STORAGE_KEY_SETTINGS = "tablesTrainerSettingsV4";

      let stats = {};
      let currentQuestion = null;
      let questionStartTime = null;
      let audioCtx = null;
      let isPaused = false;
      let pausedElapsed = 0;
      let currentMode = "tables";

      const tablesSelectEl = document.getElementById("tablesSelect");
      const squaresSelectEl = document.getElementById("squaresSelect");
      const cubesSelectEl = document.getElementById("cubesSelect");
      const questionDisplayEl = document.getElementById("questionDisplay");
      const answerInputEl = document.getElementById("answerInput");
      const feedbackEl = document.getElementById("feedback");
      const timingInfoEl = document.getElementById("timingInfo");
      const totalStatEl = document.getElementById("totalStat");
      const accuracyStatEl = document.getElementById("accuracyStat");
      const avgTimeStatEl = document.getElementById("avgTimeStat");
      const nextBtn = document.getElementById("nextBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const skipBtn = document.getElementById("skipBtn");
      const resetBtn = document.getElementById("resetBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const modeTablesBtn = document.getElementById("modeTablesBtn");
      const modeSquaresBtn = document.getElementById("modeSquaresBtn");
      const modeCubesBtn = document.getElementById("modeCubesBtn");
      const modeMixedBtn = document.getElementById("modeMixedBtn");
      const modeTrigBtn = document.getElementById("modeTrigBtn");
      const tablesSection = document.getElementById("tablesSection");
      const squaresSection = document.getElementById("squaresSection");
      const cubesSection = document.getElementById("cubesSection");
      const selectAllTablesBtn = document.getElementById("selectAllTablesBtn");
      const selectAllSquaresBtn = document.getElementById(
        "selectAllSquaresBtn"
      );
      const selectAllCubesBtn = document.getElementById("selectAllCubesBtn");
      const questionCard = document.getElementById("questionCard");
      const trigToolbar = document.getElementById("trigToolbar");
      const trigToolbarText = document.getElementById("trigToolbarText");
      const trigUnitToggle = document.getElementById("trigUnitToggle");
      const trigDegBtn = document.getElementById("trigDegBtn");
      const trigRadBtn = document.getElementById("trigRadBtn");

      /* ===== Scheduler config ===== */
      const SCHED = {
        targetTime: 1.2,
        baseNewPriority: 8,
        masteryAccuracy: 0.95,
        masteryTimeFactor: 0.6,
        minIntervalHrs: 1 / 6,
        maxIntervalHrs: 24 * 365,
        easeFactorStart: 2.5,
      };

      function ensureScheduledFields(itemKey) {
        const s = stats[itemKey] || {};
        if (!s._sched) {
          s._sched = {
            reps: 0,
            intervalHrs: 0,
            ease: SCHED.easeFactorStart,
            nextDue: 0,
            lastReviewed: 0,
          };
        }
        stats[itemKey] = s;
      }
      function scheduleItemOnResult(itemKey, correct, timeTaken) {
        ensureScheduledFields(itemKey);
        const now = Date.now();
        const s = stats[itemKey];
        const sched = s._sched;
        const isFast = timeTaken <= SCHED.targetTime;

        if (correct) {
          sched.reps = (sched.reps || 0) + 1;
          if (isFast) sched.ease = Math.min(4.0, sched.ease + 0.06);
          else sched.ease = Math.max(1.3, sched.ease - 0.03);

          if (sched.reps === 1)
            sched.intervalHrs = Math.max(SCHED.minIntervalHrs, 0.5);
          else if (sched.reps === 2)
            sched.intervalHrs = Math.max(SCHED.minIntervalHrs, 6);
          else
            sched.intervalHrs = Math.min(
              SCHED.maxIntervalHrs,
              Math.max(SCHED.minIntervalHrs, sched.intervalHrs * sched.ease)
            );
        } else {
          sched.reps = Math.max(0, (sched.reps || 0) - 1);
          sched.ease = Math.max(1.3, sched.ease - 0.2);
          sched.intervalHrs = Math.min(
            4,
            Math.max(0.08, (timeTaken / SCHED.targetTime) * 0.2)
          );
        }
        sched.lastReviewed = now;
        sched.nextDue = now + Math.round(sched.intervalHrs * 3600 * 1000);
        s._sched = sched;
        stats[itemKey] = s;
      }
      function computePriorityForItem(itemKey) {
        const s = stats[itemKey] || {};
        const sched = s._sched || {};
        const now = Date.now();
        if (!s.attempts || s.attempts === 0) return SCHED.baseNewPriority * 1.2;
        const avgTime = s.attempts
          ? s.totalTime / s.attempts
          : SCHED.targetTime * 1.5;
        const acc = s.correct ? s.correct / Math.max(1, s.attempts) : 0;
        const mastered =
          acc >= SCHED.masteryAccuracy &&
          avgTime / SCHED.targetTime <= SCHED.masteryTimeFactor;
        const nextDue = sched.nextDue || 0;
        const hoursUntilDue = (nextDue - now) / (1000 * 3600);
        const overdueBoost =
          hoursUntilDue <= 0
            ? 1 + Math.min(5, Math.abs(hoursUntilDue))
            : 1 / (1 + hoursUntilDue);
        const timeFactor = Math.min(
          6,
          Math.max(0.6, avgTime / SCHED.targetTime)
        );
        const wrongs = s.attempts - (s.correct || 0);
        const wrongFactor = 1 + Math.min(6, wrongs * 0.6);
        const repFactor = 1 / (1 + (sched.reps || 0) * 0.35);
        let weight = 1;
        if (mastered) weight = 0.3 * overdueBoost * timeFactor;
        else
          weight = Math.max(
            1,
            SCHED.baseNewPriority *
              repFactor *
              wrongFactor *
              timeFactor *
              overdueBoost
          );
        return weight;
      }

      /* ===== Storage ===== */
      function loadStats() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY_STATS);
          if (raw) stats = JSON.parse(raw);
        } catch (e) {
          stats = {};
        }
      }
      function saveStats() {
        localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(stats));
      }
      function loadSettings() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY_SETTINGS);
          if (raw) return JSON.parse(raw);
        } catch (e) {}
        return {
          selectedTables: [10, 11, 12, 13, 14, 15],
          selectedSquares: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
          selectedCubes: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
          mode: "tables",
          trigUnit: "deg",
        };
      }
      function saveSettings(s) {
        localStorage.setItem(STORAGE_KEY_SETTINGS, JSON.stringify(s));
      }

      /* ===== Build selectors ===== */
      function buildSelectors() {
        const settings = loadSettings();

        // Tables
        const tables = new Set(settings.selectedTables || []);
        tablesSelectEl.innerHTML = "";
        for (let n = 1; n <= 20; n++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "table-pill";
          btn.textContent = "× " + n;
          if (tables.has(n)) btn.classList.add("active");
          btn.addEventListener("click", () => {
            btn.classList.toggle("active");
            saveCurrentSelections();
          });
          tablesSelectEl.appendChild(btn);
        }

        // Squares
        const sq = new Set(settings.selectedSquares || []);
        squaresSelectEl.innerHTML = "";
        for (let n = 1; n <= 30; n++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "table-pill";
          btn.textContent = n;
          if (sq.has(n)) btn.classList.add("active");
          btn.addEventListener("click", () => {
            btn.classList.toggle("active");
            saveCurrentSelections();
          });
          squaresSelectEl.appendChild(btn);
        }

        // Cubes
        const cb = new Set(settings.selectedCubes || []);
        cubesSelectEl.innerHTML = "";
        for (let n = 1; n <= 20; n++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "table-pill";
          btn.textContent = n;
          if (cb.has(n)) btn.classList.add("active");
          btn.addEventListener("click", () => {
            btn.classList.toggle("active");
            saveCurrentSelections();
          });
          cubesSelectEl.appendChild(btn);
        }
      }

      function getSelectedTables() {
        const btns = tablesSelectEl.querySelectorAll("button");
        const list = [];
        btns.forEach((b, idx) => {
          if (b.classList.contains("active")) list.push(idx + 1);
        });
        return list;
      }
      function getSelectedSquares() {
        const btns = squaresSelectEl.querySelectorAll("button");
        const list = [];
        btns.forEach((b, idx) => {
          if (b.classList.contains("active")) list.push(idx + 1);
        });
        return list;
      }
      function getSelectedCubes() {
        const btns = cubesSelectEl.querySelectorAll("button");
        const list = [];
        btns.forEach((b, idx) => {
          if (b.classList.contains("active")) list.push(idx + 1);
        });
        return list;
      }
      function saveCurrentSelections() {
        const st = {
          selectedTables: getSelectedTables(),
          selectedSquares: getSelectedSquares(),
          selectedCubes: getSelectedCubes(),
          mode: currentMode,
          trigUnit,
        };
        saveSettings(st);
      }

      function selectAllTables(toggleTo) {
        const btns = tablesSelectEl.querySelectorAll("button");
        let changed = false;
        btns.forEach((b) => {
          if (typeof toggleTo === "boolean") {
            if (b.classList.contains("active") !== toggleTo) {
              b.classList.toggle("active", toggleTo);
              changed = true;
            }
          } else {
            if (!b.classList.contains("active")) {
              b.classList.add("active");
              changed = true;
            }
          }
        });
        if (changed) saveCurrentSelections();
      }
      function selectAllSquares(toggleTo) {
        const btns = squaresSelectEl.querySelectorAll("button");
        let changed = false;
        btns.forEach((b) => {
          if (typeof toggleTo === "boolean") {
            if (b.classList.contains("active") !== toggleTo) {
              b.classList.toggle("active", toggleTo);
              changed = true;
            }
          } else {
            if (!b.classList.contains("active")) {
              b.classList.add("active");
              changed = true;
            }
          }
        });
        if (changed) saveCurrentSelections();
      }
      function selectAllCubes(toggleTo) {
        const btns = cubesSelectEl.querySelectorAll("button");
        let changed = false;
        btns.forEach((b) => {
          if (typeof toggleTo === "boolean") {
            if (b.classList.contains("active") !== toggleTo) {
              b.classList.toggle("active", toggleTo);
              changed = true;
            }
          } else {
            if (!b.classList.contains("active")) {
              b.classList.add("active");
              changed = true;
            }
          }
        });
        if (changed) saveCurrentSelections();
      }

      /* ===== Audio ===== */
      function ensureAudioCtx() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      }
      function playTone(freq, duration = 0.12, type = "sine", gain = 0.28) {
        try {
          const ctx = ensureAudioCtx();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g);
          g.connect(ctx.destination);
          o.start();
          g.gain.exponentialRampToValueAtTime(
            0.0001,
            ctx.currentTime + duration
          );
          setTimeout(() => {
            try {
              o.stop();
              o.disconnect();
              g.disconnect();
            } catch (e) {}
          }, (duration + 0.02) * 1000);
        } catch (e) {}
      }
      function playCorrect() {
        playTone(880, 0.12, "sine", 0.6);
        setTimeout(() => playTone(1320, 0.14, "sine", 0.52), 110);
      }
      function playWrong() {
        playTone(220, 0.26, "sawtooth", 0.72);
      }

      /* ===== Trig data & helpers ===== */
      let trigUnit = "deg"; // 'deg' | 'rad'

      // Standard trig table with exact forms
      const TRIG_ITEMS = [
        { func: "sin", angleDeg: 0, rad: "0", display: "0", answers: ["0"] },
        { func: "cos", angleDeg: 0, rad: "0", display: "1", answers: ["1"] },
        { func: "tan", angleDeg: 0, rad: "0", display: "0", answers: ["0"] },
        { func: "sec", angleDeg: 0, rad: "0", display: "1", answers: ["1"] },

        {
          func: "sin",
          angleDeg: 30,
          rad: "π/6",
          display: "1/2",
          answers: ["1/2"],
        },
        {
          func: "cos",
          angleDeg: 30,
          rad: "π/6",
          display: "√3/2",
          answers: ["sqrt3/2", "√3/2", "root3/2"],
        },
        {
          func: "tan",
          angleDeg: 30,
          rad: "π/6",
          display: "1/√3",
          answers: ["1/sqrt3", "1/√3", "1/root3", "sqrt3/3", "√3/3", "root3/3"],
        },
        {
          func: "cosec",
          angleDeg: 30,
          rad: "π/6",
          display: "2",
          answers: ["2"],
        },
        {
          func: "sec",
          angleDeg: 30,
          rad: "π/6",
          display: "2/√3",
          answers: ["2/sqrt3", "2/√3", "2/root3"],
        },
        {
          func: "cot",
          angleDeg: 30,
          rad: "π/6",
          display: "√3",
          answers: ["sqrt3", "√3", "root3"],
        },

        {
          func: "sin",
          angleDeg: 45,
          rad: "π/4",
          display: "√2/2",
          answers: ["sqrt2/2", "√2/2", "root2/2"],
        },
        {
          func: "cos",
          angleDeg: 45,
          rad: "π/4",
          display: "√2/2",
          answers: ["sqrt2/2", "√2/2", "root2/2"],
        },
        { func: "tan", angleDeg: 45, rad: "π/4", display: "1", answers: ["1"] },
        {
          func: "cosec",
          angleDeg: 45,
          rad: "π/4",
          display: "√2",
          answers: ["sqrt2", "√2", "root2"],
        },
        {
          func: "sec",
          angleDeg: 45,
          rad: "π/4",
          display: "√2",
          answers: ["sqrt2", "√2", "root2"],
        },
        { func: "cot", angleDeg: 45, rad: "π/4", display: "1", answers: ["1"] },

        {
          func: "sin",
          angleDeg: 60,
          rad: "π/3",
          display: "√3/2",
          answers: ["sqrt3/2", "√3/2", "root3/2"],
        },
        {
          func: "cos",
          angleDeg: 60,
          rad: "π/3",
          display: "1/2",
          answers: ["1/2"],
        },
        {
          func: "tan",
          angleDeg: 60,
          rad: "π/3",
          display: "√3",
          answers: ["sqrt3", "√3", "root3"],
        },
        {
          func: "cosec",
          angleDeg: 60,
          rad: "π/3",
          display: "2/√3",
          answers: ["2/sqrt3", "2/√3", "2/root3"],
        },
        { func: "sec", angleDeg: 60, rad: "π/3", display: "2", answers: ["2"] },
        {
          func: "cot",
          angleDeg: 60,
          rad: "π/3",
          display: "1/√3",
          answers: ["1/sqrt3", "1/√3", "1/root3", "sqrt3/3", "√3/3", "root3/3"],
        },

        { func: "sin", angleDeg: 90, rad: "π/2", display: "1", answers: ["1"] },
        { func: "cos", angleDeg: 90, rad: "π/2", display: "0", answers: ["0"] },
        {
          func: "cosec",
          angleDeg: 90,
          rad: "π/2",
          display: "1",
          answers: ["1"],
        },
        { func: "cot", angleDeg: 90, rad: "π/2", display: "0", answers: ["0"] },
      ];

      function normalizeTrigInput(str) {
        let s = str.toLowerCase();
        s = s.replace(/\s+/g, "");
        s = s.replace(/√/g, "sqrt");
        s = s.replace(/root/g, "sqrt");
        return s;
      }

      function trigFormatAngle(item) {
        return trigUnit === "deg" ? item.angleDeg + "°" : item.rad;
      }

      function trigPickQuestion() {
        const idx = Math.floor(Math.random() * TRIG_ITEMS.length);
        return TRIG_ITEMS[idx];
      }

      /* ===== Candidate generation (tables,squares,cubes,trig) ===== */
      function pickNextQuestion() {
        if (currentMode === "trig") {
          // trig pool only
          const pool = [];
          TRIG_ITEMS.forEach((item) => {
            const key = `trig ${item.func} ${item.angleDeg}`;
            if (!stats[key])
              stats[key] = {
                func: item.func,
                angleDeg: item.angleDeg,
                type: "trig",
                attempts: 0,
                correct: 0,
                totalTime: 0,
              };
            ensureScheduledFields(key);
            pool.push({
              type: "trig",
              func: item.func,
              angleDeg: item.angleDeg,
              rad: item.rad,
              display: item.display,
              answers: item.answers,
              key,
            });
          });
          const scored = pool.map((item) => ({
            item,
            weight: computePriorityForItem(item.key),
          }));
          // simple weighted choice + buckets
          const struggling = [],
            learning = [],
            review = [];
          scored.forEach((obj) => {
            const s = stats[obj.item.key];
            const acc = s.attempts ? s.correct / s.attempts : 0;
            const attempts = s.attempts || 0;
            if (attempts <= 1) learning.push(obj);
            else if (acc < 0.7 || obj.weight > SCHED.baseNewPriority * 0.9)
              struggling.push(obj);
            else review.push(obj);
          });
          function pickFromBucket(bucket) {
            if (!bucket.length) return null;
            const total = bucket.reduce((sum, b) => sum + b.weight, 0);
            let r = Math.random() * total;
            for (const b of bucket) {
              if (r < b.weight) return b.item;
              r -= b.weight;
            }
            return bucket[bucket.length - 1].item;
          }
          const rand = Math.random();
          let pick = null;
          if (rand < 0.4 && struggling.length)
            pick = pickFromBucket(struggling);
          else if (rand < 0.7 && learning.length)
            pick = pickFromBucket(learning);
          else if (review.length) pick = pickFromBucket(review);
          else
            pick =
              pickFromBucket(struggling) ||
              pickFromBucket(learning) ||
              pickFromBucket(review) ||
              (scored.length ? scored[0].item : null);
          return pick;
        }

        const selectedTables = getSelectedTables();
        const selectedSquares = getSelectedSquares();
        const selectedCubes = getSelectedCubes();

        if (currentMode === "tables" && !selectedTables.length) {
          alert("Select at least one table");
          return null;
        }
        if (currentMode === "squares" && !selectedSquares.length) {
          alert("Select at least one square");
          return null;
        }
        if (currentMode === "cubes" && !selectedCubes.length) {
          alert("Select at least one cube");
          return null;
        }
        if (
          currentMode === "mixed" &&
          !selectedTables.length &&
          !selectedSquares.length &&
          !selectedCubes.length
        ) {
          alert("Select at least one table, square or cube for Mixed mode");
          return null;
        }

        const pool = [];
        if (currentMode === "tables" || currentMode === "mixed") {
          selectedTables.forEach((base) => {
            for (let m = 1; m <= 10; m++) {
              const key = `t ${base}x${m}`;
              if (!stats[key])
                stats[key] = {
                  a: base,
                  b: m,
                  attempts: 0,
                  correct: 0,
                  totalTime: 0,
                  type: "table",
                };
              ensureScheduledFields(key);
              pool.push({ type: "table", a: base, b: m, key });
            }
          });
        }
        if (currentMode === "squares" || currentMode === "mixed") {
          selectedSquares.forEach((n) => {
            const key = `s ${n}`;
            if (!stats[key])
              stats[key] = {
                n,
                attempts: 0,
                correct: 0,
                totalTime: 0,
                type: "square",
              };
            ensureScheduledFields(key);
            pool.push({ type: "square", n, key });
          });
        }
        if (currentMode === "cubes" || currentMode === "mixed") {
          selectedCubes.forEach((n) => {
            const key = `c ${n}`;
            if (!stats[key])
              stats[key] = {
                n,
                attempts: 0,
                correct: 0,
                totalTime: 0,
                type: "cube",
              };
            ensureScheduledFields(key);
            pool.push({ type: "cube", n, key });
          });
        }

        const scored = pool.map((item) => ({
          item,
          weight: computePriorityForItem(item.key),
        }));
        const struggling = [],
          learning = [],
          review = [];
        scored.forEach((obj) => {
          const s = stats[obj.item.key];
          const acc = s.attempts ? s.correct / s.attempts : 0;
          const attempts = s.attempts || 0;
          if (attempts <= 1) learning.push(obj);
          else if (acc < 0.7 || obj.weight > SCHED.baseNewPriority * 0.9)
            struggling.push(obj);
          else review.push(obj);
        });
        function pickFromBucket(bucket) {
          if (!bucket.length) return null;
          const total = bucket.reduce((sum, b) => sum + b.weight, 0);
          let r = Math.random() * total;
          for (const b of bucket) {
            if (r < b.weight) return b.item;
            r -= b.weight;
          }
          return bucket[bucket.length - 1].item;
        }
        const rand = Math.random();
        let pick = null;
        if (rand < 0.4 && struggling.length) pick = pickFromBucket(struggling);
        else if (rand < 0.7 && learning.length) pick = pickFromBucket(learning);
        else if (review.length) pick = pickFromBucket(review);
        else
          pick =
            pickFromBucket(struggling) ||
            pickFromBucket(learning) ||
            pickFromBucket(review) ||
            (scored.length ? scored[0].item : null);
        return pick;
      }

      /* ===== Show + submit logic ===== */
      function showNewQuestion() {
        isPaused = false;
        pausedElapsed = 0;
        pauseBtn.textContent = "Pause";
        const q = pickNextQuestion();
        if (!q) return;
        currentQuestion = q;
        questionStartTime = performance.now();

        if (q.type === "table")
          questionDisplayEl.textContent = `${q.a} × ${q.b} = ?`;
        else if (q.type === "square")
          questionDisplayEl.textContent = `${q.n}² = ?`;
        else if (q.type === "cube")
          questionDisplayEl.textContent = `${q.n}³ = ?`;
        else if (q.type === "trig") {
          const fakeItem = TRIG_ITEMS.find(
            (it) => it.func === q.func && it.angleDeg === q.angleDeg
          );
          const angleLabel = trigFormatAngle(fakeItem || q);
          questionDisplayEl.textContent = `${q.func} ${angleLabel} = ?`;
        }

        // placeholder per mode
        if (currentMode === "trig") {
          answerInputEl.placeholder = "e.g. √3/2, 1/√3";
        } else {
          answerInputEl.placeholder = "Type answer & press Enter";
        }

        feedbackEl.textContent = "";
        feedbackEl.className = "feedback";
        timingInfoEl.textContent = "";
        answerInputEl.value = "";
        answerInputEl.focus();
      }

      function submitAnswer() {
        if (isPaused) {
          feedbackEl.textContent = "Paused — press Resume to continue timing.";
          feedbackEl.className = "feedback wrong";
          return;
        }
        if (!currentQuestion || questionStartTime === null) {
          showNewQuestion();
          return;
        }

        const raw = answerInputEl.value.trim();
        const end = performance.now();
        const elapsedBefore = pausedElapsed || 0;
        const timeTaken = (end - questionStartTime) / 1000 + elapsedBefore;
        questionStartTime = null;
        pausedElapsed = 0;

        // TRIG MODE:
        if (currentQuestion.type === "trig") {
          if (raw === "") {
            feedbackEl.textContent = "Type a value like √3/2, 1/√3, √2/2 …";
            feedbackEl.className = "feedback wrong";
            return;
          }
          const normalized = normalizeTrigInput(raw);
          const key = currentQuestion.key;
          const fakeItem = TRIG_ITEMS.find(
            (it) =>
              it.func === currentQuestion.func &&
              it.angleDeg === currentQuestion.angleDeg
          );
          const angleLabel = trigFormatAngle(fakeItem || currentQuestion);
          const display = (fakeItem || currentQuestion).display;
          const allowed = (fakeItem || currentQuestion).answers.map(
            normalizeTrigInput
          );

          const isCorrect = allowed.includes(normalized);

          if (!stats[key])
            stats[key] = {
              func: currentQuestion.func,
              angleDeg: currentQuestion.angleDeg,
              type: "trig",
              attempts: 0,
              correct: 0,
              totalTime: 0,
            };
          const s = stats[key];
          s.attempts += 1;
          if (isCorrect) s.correct = (s.correct || 0) + 1;
          s.totalTime = (s.totalTime || 0) + timeTaken;
          s.lastTime = timeTaken;
          s.lastCorrect = isCorrect;
          s.history = s.history || [];
          s.history.push({
            timestamp: new Date().toISOString(),
            userAnswer: raw,
            correctAnswer: display,
            time: timeTaken,
          });

          scheduleItemOnResult(key, isCorrect, timeTaken);
          saveStats();
          updateStatsDisplay();

          if (isCorrect) {
            feedbackEl.textContent = `Correct ✅  ${currentQuestion.func} ${angleLabel} = ${display}`;
            feedbackEl.className = "feedback correct";
            playCorrect();
            questionCard.classList.add("flash-correct");
            setTimeout(
              () => questionCard.classList.remove("flash-correct"),
              700
            );
          } else {
            feedbackEl.textContent = `Wrong ❌  ${currentQuestion.func} ${angleLabel} = ${display}`;
            feedbackEl.className = "feedback wrong";
            playWrong();
            questionCard.classList.add("flash-wrong");
            setTimeout(() => questionCard.classList.remove("flash-wrong"), 700);
          }
          timingInfoEl.textContent = `Time: ${timeTaken.toFixed(2)} s`;
          setTimeout(showNewQuestion, 700);
          return;
        }

        // NUMERIC MODES:
        const userVal = parseInt(raw, 10);
        if (isNaN(userVal)) {
          feedbackEl.textContent = "Type your answer and press Enter.";
          feedbackEl.className = "feedback wrong";
          return;
        }

        let correctAnswer;
        if (currentQuestion.type === "table")
          correctAnswer = currentQuestion.a * currentQuestion.b;
        else if (currentQuestion.type === "square")
          correctAnswer = currentQuestion.n * currentQuestion.n;
        else
          correctAnswer =
            currentQuestion.n * currentQuestion.n * currentQuestion.n;
        const key = currentQuestion.key;
        const isCorrect = userVal === correctAnswer;

        if (!stats[key])
          stats[key] = {
            a: currentQuestion.a,
            b: currentQuestion.b,
            n: currentQuestion.n,
            attempts: 0,
            correct: 0,
            totalTime: 0,
            type: currentQuestion.type || "unknown",
          };
        const s = stats[key];
        s.attempts += 1;
        if (isCorrect) s.correct = (s.correct || 0) + 1;
        s.totalTime = (s.totalTime || 0) + timeTaken;
        s.lastTime = timeTaken;
        s.lastCorrect = isCorrect;
        s.history = s.history || [];
        s.history.push({
          timestamp: new Date().toISOString(),
          userAnswer: userVal,
          correctAnswer,
          time: timeTaken,
        });

        scheduleItemOnResult(key, isCorrect, timeTaken);
        saveStats();
        updateStatsDisplay();

        if (isCorrect) {
          feedbackEl.textContent = "Correct ✅";
          feedbackEl.className = "feedback correct";
          playCorrect();
          questionCard.classList.add("flash-correct");
          setTimeout(() => questionCard.classList.remove("flash-correct"), 700);
        } else {
          feedbackEl.textContent = `Wrong ❌  Correct answer is ${correctAnswer}`;
          feedbackEl.className = "feedback wrong";
          playWrong();
          questionCard.classList.add("flash-wrong");
          setTimeout(() => questionCard.classList.remove("flash-wrong"), 700);
        }
        timingInfoEl.textContent = `Time: ${timeTaken.toFixed(2)} s`;
        setTimeout(showNewQuestion, 700);
      }

      function pauseOrResume() {
        if (!currentQuestion) return;
        if (!isPaused) {
          const now = performance.now();
          pausedElapsed = (now - questionStartTime) / 1000;
          questionStartTime = null;
          isPaused = true;
          pauseBtn.textContent = "Resume";
          feedbackEl.textContent = "Paused — timing stopped.";
          feedbackEl.className = "feedback wrong";
        } else {
          questionStartTime = performance.now();
          isPaused = false;
          pauseBtn.textContent = "Pause";
          feedbackEl.textContent = "Resumed — timing continues.";
          feedbackEl.className = "feedback";
          answerInputEl.focus();
        }
      }
      function skipQuestion() {
        if (!currentQuestion) {
          showNewQuestion();
          return;
        }
        feedbackEl.textContent = "Skipped — no record saved.";
        feedbackEl.className = "feedback wrong";
        questionStartTime = null;
        pausedElapsed = 0;
        isPaused = false;
        setTimeout(showNewQuestion, 300);
      }

      function updateStatsDisplay() {
        const all = Object.values(stats);
        const totalAttempts = all.reduce(
          (acc, s) => acc + (s.attempts || 0),
          0
        );
        const totalCorrect = all.reduce((acc, s) => acc + (s.correct || 0), 0);
        const totalTime = all.reduce((acc, s) => acc + (s.totalTime || 0), 0);
        totalStatEl.textContent = `Total: ${totalAttempts}`;
        if (totalAttempts === 0) {
          accuracyStatEl.textContent = "Accuracy: –";
          avgTimeStatEl.textContent = "Avg time: –";
        } else {
          const acc = (100 * totalCorrect) / totalAttempts;
          const avg = totalTime / totalAttempts;
          accuracyStatEl.textContent = `Accuracy: ${acc.toFixed(1)}%`;
          avgTimeStatEl.textContent = `Avg time: ${avg.toFixed(2)} s`;
        }
      }

      function resetStats() {
        if (!confirm("Reset all stats and start fresh?")) return;
        stats = {};
        saveStats();
        updateStatsDisplay();
      }

      function downloadLog() {
        const all = Object.entries(stats);
        if (!all.length) {
          alert("No stats yet to export.");
          return;
        }
        let lines = [
          "key,type,question,attempts,correct,totalTime,avgTime,lastTime,lastCorrect",
        ];
        all.forEach(([key, s]) => {
          const avg = s.attempts ? s.totalTime / s.attempts : 0;
          let qText = key;
          if (s.type === "table") qText = `${s.a}x${s.b}`;
          else if (s.type === "square") qText = `${s.n}^2`;
          else if (s.type === "cube") qText = `${s.n}^3`;
          else if (s.type === "trig") qText = `${s.func}(${s.angleDeg})`;
          lines.push(
            [
              key,
              s.type || "",
              `"${qText}"`,
              s.attempts || 0,
              s.correct || 0,
              (s.totalTime || 0).toFixed(3),
              avg.toFixed(3),
              (s.lastTime || 0).toFixed(3),
              s.lastCorrect ? "true" : "false",
            ].join(",")
          );
        });
        const blob = new Blob([lines.join("\n")], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "tables-trainer-log.txt";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function setTrigUnit(unit) {
        trigUnit = unit;
        trigDegBtn.classList.toggle("active", unit === "deg");
        trigRadBtn.classList.toggle("active", unit === "rad");
        saveCurrentSelections();
        // update question text if currently trig
        if (currentQuestion && currentQuestion.type === "trig") {
          const fakeItem = TRIG_ITEMS.find(
            (it) =>
              it.func === currentQuestion.func &&
              it.angleDeg === currentQuestion.angleDeg
          );
          const angleLabel = trigFormatAngle(fakeItem || currentQuestion);
          questionDisplayEl.textContent = `${currentQuestion.func} ${angleLabel} = ?`;
        }
      }

      function setMode(mode) {
        currentMode = mode;
        document
          .querySelectorAll(".mode-btn")
          .forEach((b) =>
            b.classList.toggle("active", b.dataset.mode === mode)
          );
        tablesSection.style.display =
          mode === "tables" || mode === "mixed" ? "block" : "none";
        squaresSection.style.display =
          mode === "squares" || mode === "mixed" ? "block" : "none";
        cubesSection.style.display =
          mode === "cubes" || mode === "mixed" ? "block" : "none";

        // trig UI bits
        if (mode === "trig") {
          trigUnitToggle.style.display = "flex";
          trigToolbar.style.display = "flex";
          trigToolbarText.style.display = "block";
          answerInputEl.placeholder = "e.g. √3/2, 1/√3";
        } else {
          trigUnitToggle.style.display = "none";
          trigToolbar.style.display = "none";
          trigToolbarText.style.display = "none";
          answerInputEl.placeholder = "Type answer & press Enter";
        }

        saveCurrentSelections();
      }
      function restoreMode() {
        const s = loadSettings();
        trigUnit = s.trigUnit || "deg";
        setTrigUnit(trigUnit);
        setMode(s.mode || "tables");
      }

      function wireEvents() {
        nextBtn.addEventListener("click", showNewQuestion);
        pauseBtn.addEventListener("click", pauseOrResume);
        skipBtn.addEventListener("click", skipQuestion);
        resetBtn.addEventListener("click", resetStats);
        downloadBtn.addEventListener("click", downloadLog);
        answerInputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") submitAnswer();
        });

        modeTablesBtn.addEventListener("click", () => setMode("tables"));
        modeSquaresBtn.addEventListener("click", () => setMode("squares"));
        modeCubesBtn.addEventListener("click", () => setMode("cubes"));
        modeMixedBtn.addEventListener("click", () => setMode("mixed"));
        modeTrigBtn.addEventListener("click", () => setMode("trig"));

        selectAllTablesBtn.addEventListener("click", () => {
          const btns = tablesSelectEl.querySelectorAll("button");
          const anyUnchecked = Array.from(btns).some(
            (b) => !b.classList.contains("active")
          );
          selectAllTables(anyUnchecked);
        });
        selectAllSquaresBtn.addEventListener("click", () => {
          const btns = squaresSelectEl.querySelectorAll("button");
          const anyUnchecked = Array.from(btns).some(
            (b) => !b.classList.contains("active")
          );
          selectAllSquares(anyUnchecked);
        });
        selectAllCubesBtn.addEventListener("click", () => {
          const btns = cubesSelectEl.querySelectorAll("button");
          const anyUnchecked = Array.from(btns).some(
            (b) => !b.classList.contains("active")
          );
          selectAllCubes(anyUnchecked);
        });

        // trig toolbar insert buttons
        trigToolbar.querySelectorAll(".trig-toolbar-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const val = btn.dataset.insert || "";
            const el = answerInputEl;
            const start = el.selectionStart ?? el.value.length;
            const end = el.selectionEnd ?? el.value.length;
            const before = el.value.slice(0, start);
            const after = el.value.slice(end);
            el.value = before + val + after;
            const newPos = start + val.length;
            el.selectionStart = el.selectionEnd = newPos;
            el.focus();
          });
        });

        trigDegBtn.addEventListener("click", () => setTrigUnit("deg"));
        trigRadBtn.addEventListener("click", () => setTrigUnit("rad"));
      }

      function init() {
        loadStats();
        buildSelectors();
        restoreMode();
        updateStatsDisplay();
        wireEvents();
      }

      init();
    </script>
  </body>
</html>
